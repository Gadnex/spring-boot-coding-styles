# spring-boot-coding-styles

## Background
A sample Spring Boot application to compare different coding styles.

## Prerequisites
- Java 17

## Running Application
Run the command in the root of the project.
### Windows
```bash
gradlew.bat bootRun
 ```
### Linux
```bash
./gradlew bootRun
```

## OpenAPI/Swagger UI
The OpenAPI/Swagger UI can be found at the following link:
http://localhost:9080/actuator/swagger-ui/index.html

All documentation about testing the application is found here.

## Database
The system uses an H2 in memory database that can be accessed at the following URL:  
http://localhost:8080/h2-console
The following details can be used to access the database:

**Driver Class:** org.h2.Driver  
**JDBC URL:** jdbc:h2:mem:testdb  
**User Name:** sa  
**Password:** 

## Coding Styles

### Step 1

This code example uses the coding styles used in most Spring Boot tuturials and should be familiar to most Spring Boot developers. 
This is a good starting point for our comparisons as we are familiar with this coding style.

This code branch has a total of 11 Java code files and 224 lines of Java code excluding blank lines.

### Step 2

The first improvement I would look for is the removal of unneccesary interfaces.
Many Spring Boot developers avoid these by default, so it is a good starting point, but it is a topic worth discussing.

I can think of 3 reasons why we would use interfaces in Java:

    1. When we use the interface as the contract between two teams or modules either in a monolith or using some RPC mechanism.
       In this scenario one team would implement the interface and play the role of the server.
       The other team will call the interface and play the role of the client.
       In this case I would put the interface in a separate package or module where both teams can access it.
       Any changes in this interface would have to be negotiated and agreed to by both teams.
    2. When there are multiple implementations of the interface.
       For example, if we are building a software product that can work with an Oracle Database and a Postgress database
       we might want to have 2 implementations of a Data Access Object (DAO) interface, one for each database.
       This usage of interfaces can largely be avoided by using modern object-relational mapping technologies susch as
       JPA and/or Spring Data.
       Also when building software for enterprises and not as prooducts this type of flexibility is hardly ever required.
    3. When unit testing a layeded application, injecting an interface of the layer below instead of a concrete class makes it
       possible for the unit test to code to inject a mock implementation of the interface instead of the real implementation.
       This problem has largely been solved by technologies such as Mockito, which has not issue mocking a concrete class for unit testing.

In our application we only have one such unneccesary interface i.e. PersonService, so lets remove it.

This code branch has a total of 10 Java code files and 212 lines of Java code excluding blank lines.

### Step 3

Our Data Transfer Objects (DTO) classes are basically different versions of the Entity classes used to represent the entity classes in different ways in our REST APIs.
For example, when we want to create a new person, we want to specify all the fields of the person except the id, because the id field will be generated by our database auto numbering. When we return a list of persons, we do not want to return all the fields of the person in order to limit the number of bytes send over the network. But when we return a single person, we want to return all of its fields.
Data Transfer Objects (DTO) allow us to create these different views of an entity object.

But DTOs are duplicating lots of code and it is easy to forget that when you add or remove fields from the entity class to also update all the DTO classes.

DTO classes also create the need for mapper classes and code to convert entity objects to DTO objects and vice versa. These mapper classes can be written manually as in this example, or using a tool such as MapStruct.

But there is another way to solve the issue of DTO classes for JSON based REST APIs. The JSON serialization tool used by Spring Boot is called Jackson and Jackson has a nice annotations for creating DTO classes dynamically. This annotation is called @JsonView. With @JsonView you can specify on the field itself which DTOs this field has to be included in. The DTO's can be any class or interface. In your REST controllers you will also use the @JsonView annotation to specify which DTO you want to use for input parameters and response values.

The nice thing about making the DTOs classes or interfaces is because Bean Validation (JSR 303) also has a concept of validation groups where these groups are classes or interfaces to filter the data validations to be applied.
For example, when creating a person the id should be null as the id will be created by the database on save. But when updating a person, the id may not be null as we need to specify which person to update.

The similarities between DTOs and validation groups should start to become clear now.

So let's update the code to remove the DTOs and mapper classes and replace them with the @JsonView annotations and interfaces to represent the DTOs and validation groups. We are also going to move the Bean Validation anotations and OpenApi/Swagger annotations on the DTO classes to the entity classes so that all info about the entity is together in one place. As a side effect our OpenApi/Swagger documentation for the DTOs will also be improved.

This code branch has a total of 6 Java code files and 172 lines of Java code excluding blank lines.

### Step 4

Next we want to take a serious look at the layers in our application. The reason we have layers in our application at all is for separation of concerns. Thus every technical concern should have its own layer.

In our initial code from Step 1, the controller layer was responsible for converting/mapping between entity objects and DTO objects and vice versa. But this logic has been completely removed in Step 3 as the Jackson @JsonView annotations takes care of DTOs for us. The service layer is still unchanged and is responsible for the business logic of the application, which includes the calls to the repository layer of the application.

Now it seems we have one fewer concern due to the usage of the @JsonView annotations, and thus we should technically have one fewer layer as well.

But what should we call this layer? Should it be the Controller layer that now is only responsible for the business logic, or do we call it the service layer. Since we are going to annotate this layer with the Spring @RestController annotation, I would prefer calling it the controller layer.

Please take causion. In your application you may still have more concerns and thus may need more layers.

This code branch has a total of 5 Java code files and 151 lines of Java code excluding blank lines.

### Step 5

This is a good opportunity to discuss code packaging. Code packages are a way to organize your code classes by grouoing similar or related classes together in a directory/folder in a logical manner. This makes it easier for developers to navigate the code base and find the classes they are looking for when making code changes and bug fixes.

From the perspective of the compiler code packages are less important as the compiler is quite happy if all your classes are in a single package. Other developers and your future self will not think this was a good idea.

When packaging code the main goal is to never have a list that is to long to read before selecting one of the items.

In the past with large monolithic applications it was proposed to create a package for every layer of your appliccation. So you would think of the change you want to make and in what layer the changes should be i.e. presentation layer, business logic layer and persistence layer. When opening a layer you would be presented with a long list of classes sorted alphabetically and you could find the class that you are looking for if you know its name. This is commonly referred to as "Package by Layer".

But with the advent of Domain Driven Design and later Microservice Architectures there has been a tendensy of creating packages per business domain or functional area. This package would contain all the classes related to that business domain or functional area. This is commonly referred to as "Package by Function".

With Microservice architectures specifically, there tends to be very few business domains per microservice, but they would still likelike be more than one. Thus for monoliths "Package by Layer" makes more sence and for microservices "Package by Function" makes more sense.

I should add that a combination of the 2 styles is also possible, and that is the approach we used in Step 1 of our code. Here were created a package per function for the Person domain. Within this person package we created packages by layer.

In the code from Step 5 we had already removed some layers and now we re left with 3 packages and 1 class per package. It now makes sence to switch to a simpler "Package by Function" approach.

This code branch has a total of 5 Java code files and 148 lines of Java code excluding blank lines.

### Step 6

One common critisizm of the coding style in Step 5 is that it is quite annotation heavy. This is a common critisizm of Spring Boot in general. Either you like annotations or you do not.

In my opinion the annotations on the fields of the entity classes are not really an issue at all. There is a blank line between every field and thus easy to find the field you are looking for.

On the REST controllers the annotations do cause a bit of a problem. We have lots of annotations above every REST method to define the REST interface with things like HTTP methods, response DTO classes and OpenApi/Swagger documentation. Then we also have annotations on the method parameters for request DTO classes, data validation and OpenApi/Swagger documentation. All these annotations sometimes get in the way if you just want to look at the business logic in the method.

Here we will benefit by separtating these concerns of REST interface and business logic. But we do not want a full fledged layer for the REST interface where it call methods on the business logic layer. Here a simple interface and implementation class with suffice. Our REST interface will carry all of the REST annotations and our implementing class will take care of the business logic.

Here we also need to be smart with terminology. An interface called PersonController and an implementing class called PersonControllerImpl is not an ideal solution. We will call the interface PersonResource to refer to the REST resource and the implementing class will be called PersonController as it needs to be annotated with @RestController.

This code branch has a total of 6 Java code files and 158 lines of Java code excluding blank lines.

## Conclusion

Code quality, cleanliness and readibility is highly subjective. At the end of the day what is important is if normal human beings can easily navigate and read our code. There are other measures of good quality code that are unrelated to readibility and cleanliness and sometimes we need to make compromises to readibility and cleanliness to accomodate these other measures.

What we should not do is simply accept the status quo without understanding the logic behind it. Thus missing out on the opportunities we have to find better ways of writing code and to write better and more maintainable code faster.

If the code behind a piece of functionality is spread over fewer code files and take up fewer lines of code, then it will unquestionably be easier for developers to follow and read. But don't forget about separation of concerns and thus writing a 1000 lines of code in a single method.

In general strive to separate solving business/domain problems from solving technical/implementation problems. Saving data about a person in a database is a business/domain problem, but creating various DTOs to represent that person in different scenarios is a technical/implementation problem.

Try solving technical/implementation problems is separate and reusable code libraries and include these libraries with your dependency management tools. Mayby the technical/implementation problem you have has already been solved, even by a dependency you already have on your project. The @JsonView annotation is exactly such an example for solving the DTO problem in an elegant way.

In this project we were able to refactor our initial code to have 30% fewer lines of code while making our code easier to read and maintain. We did this by reasoning about various aspects of our code and finding ways to improve our code one step at a time.