# spring-boot-coding-styles

## Background
A sample Spring Boot application to compare different coding styles.

## Prerequisites
- Java 17

## Running Application
Run the command in the root of the project.
### Windows
```bash
gradlew.bat bootRun
 ```
### Linux
```bash
./gradlew bootRun
```

## OpenAPI/Swagger UI
The OpenAPI/Swagger UI can be found at the following link:
http://localhost:9080/actuator/swagger-ui/index.html

All documentation about testing the application is found here.

## Database
The system uses an H2 in memory database that can be accessed at the following URL:  
http://localhost:8080/h2-console
The following details can be used to access the database:

**Driver Class:** org.h2.Driver  
**JDBC URL:** jdbc:h2:mem:testdb  
**User Name:** sa  
**Password:** 

## Coding Styles

### Step 1

This code example uses the coding styles used in most Spring Boot tuturials and should be familiar to most Spring Boot developers. 
This is a good starting point for our comparisons as we are familiar with this coding style.

This code branch has a total of 11 Java code files and 224 lines of Java code excluding blank lines.

### Step 2

The first improvement I would look for is the removal of unneccesary interfaces.
Many Spring Boot developers avoid these by default, so it is a good starting point, but it is a topic worth discussing.

I can think of 3 reasons why we would use interfaces in Java:

    1. When we use the interface as the contract between two teams or modules either in a monolith or using some RPC mechanism.
       In this scenario one team would implement the interface and play the role of the server.
       The other team will call the interface and play the role of the client.
       In this case I would put the interface in a separate package or module where both teams can access it.
       Any changes in this interface would have to be negotiated and agreed to by both teams.
    2. When there are multiple implementations of the interface.
       For example, if we are building a software product that can work with an Oracle Database and a Postgress database
       we might want to have 2 implementations of a Data Access Object (DAO) interface, one for each database.
       This usage of interfaces can largely be avoided by using modern object-relational mapping technologies susch as
       JPA and/or Spring Data.
       Also when building software for enterprises and not as prooducts this type of flexibility is hardly ever required.
    3. When unit testing a layeded application, injecting an interface of the layer below instead of a concrete class makes it
       possible for the unit test to code to inject a mock implementation of the interface instead of the real implementation.
       This problem has largely been solved by technologies such as Mockito, which has not issue mocking a concrete class for unit testing.

In our application we only have one such unneccesary interface i.e. PersonService, so lets remove it.

This code branch has a total of 10 Java code files and 212 lines of Java code excluding blank lines.

### Step 3

Our Data Transfer Objects (DTO) classes are basically different versions of the Entity classes used to represent the entity classes in different ways in our REST APIs.
For example, when we want to create a new person, we want to specify all the fields of the person except the id, because the id field will be generated by our database auto numbering. When we return a list of persons, we do not want to return all the fields of the person in order to limit the number of bytes send over the network. But when we return a single person, we want to return all of its fields.
Data Transfer Objects (DTO) allow us to create these different views of an entity object.

But DTOs are duplicating lots of code and it is easy to forget that when you add or remove fields from the entity class to also update all the DTO classes.

DTO classes also create the need for mapper classes and code to convert entity objects to DTO objects and vice versa. These mapper classes can be written manually as in this example, or using a tool such as MapStruct.

But there is another way to solve the issue of DTO classes for JSON based REST APIs. The JSON serialization tool used by Spring Boot is called Jackson and Jackson has a nice annotations for creating DTO classes dynamically. This annotation is called @JsonView. With @JsonView you can specify on the field itself which DTOs this field has to be included in. The DTO's can be any class or interface. In your REST controllers you will also use the @JsonView annotation to specify which DTO you want to use for input parameters and response values.

The nice thing about making the DTOs classes or interfaces is because Bean Validation (JSR 303) also has a concept of validation groups where these groups are classes or interfaces to filter the data validations to be applied.
For example, when creating a person the id should be null as the id will be created by the database on save. But when updating a person, the id may not be null as we need to specify which person to update.

The similarities between DTOs and validation groups should start to become clear now.

So let's update the code to remove the DTOs and mapper classes and replace them with the @JsonView annotations and interfaces to represent the DTOs and validation groups. We are also going to move the Bean Validation anotations and OpenApi/Swagger annotations on the DTO classes to the entity classes so that all info about the entity is together in one place. As a side effect our OpenApi/Swagger documentation for the DTOs will also be improved.

This code branch has a total of 6 Java code files and 172 lines of Java code excluding blank lines.

### Step 4

Next we want to take a serious look at the layers in our application. The reason we have layers in our application at all is for separation of concerns. Thus every technical concern should have its own layer.

In our initial code from Step 1, the controller layer was responsible for converting/mapping between entity objects and DTO objects and vice versa. But this logic has been completely removed in Step 3 as the Jackson @JsonView annotations takes care of DTOs for us. The service layer is still unchanged and is responsible for the business logic of the application, which includes the calls to the repository layer of the application.

Now it seems we have one fewer concern due to the usage of the @JsonView annotations, and thus we should technically have one fewer layer as well.

But what should we call this layer? Should it be the Controller layer that now is only responsible for the business logic, or do we call it the service layer. Since we are going to annotate this layer with the Spring @RestController annotation, I would prefer calling it the controller layer.

Please take causion. In your application you may still have more concerns and thus may need more layers.

This code branch has a total of 5 Java code files and 151 lines of Java code excluding blank lines.